---------------------------------------------------------------------------------
输入输出：
cin/cout:
cin >> 变量;
cin.get(char ch);		//表示读取一个字符（转变成int型需要强制类型转换）返回值：char型变量???
cout << 变量/字符串/endl;

---------------------------------------------------------------------------------
printf:
printf("%x",变量名);
printf("%.nx",变量名);	//表示保留n位小数(float型)/打印数字的最小位数(整型)
printf("%nx",变量名);	//表示最小字段宽度

---------------------------------------------------------------------------------
大数处理：
9*10^18:long long类型即可表示

利用数组int a[]或者字符串char a[]（本质上也是数组，但是可以处理表达式等问题）来储存大数；
前者在处理诸如给定a,b，求a^b问题比较好用；
后者在处理注入表达式的问题时候比较好用。

↑实际上利用cin.get(temp)指令或者getchar()指令似乎很难用到int类型的数组，相应的常使用char类型的数组。
使用时候，记得
int('0')==48;
int('*')==42;
int('+')==43;
int('-')==45;
int('/')==47;
↑考试的时候如果忘记了可以利用强制类型转换配合cout/printf指令得到结果，但是相对来说比较浪费时间。
并且依据a[],b[]（若涉及2个数组）的序号关系进行处理。
---------------------------------------------------------------------------------
换空瓶子问题：
		temp = 0;
		while (bot >= f) {
			c_num = bot - bot % f;
			bot -= c_num;
			bot += c_num / f;
			temp += c_num / f;
		}
---------------------------------------------------------------------------------
求a,b的最大公约数：
1.辗转相除法（稳定在O(logn)）
	递归版本（伪代码）：
		int gcd(int a, int b) {
			if (a%b != 0) return gcd(b, a%b);
			else return b;
		}
2.更相减损法（会退化成O(n)）
3.stein算法

求a,b的最小公倍数：
a*b/gcd(a,b)即为最小公倍数
---------------------------------------------------------------------------------
设计节点与单链表：
		typedef struct LNode{
			ElemType data;
			struct LNode *next;
		}LNode, *LinkList;